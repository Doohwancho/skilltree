<!DOCTYPE html>
<html>

<head>
    <title>Skill Tree Visualization</title>
    <style id="dynamicStyles">
        /* Define rarity colors */
        :root {
            --rarity-gold: #FFD700;
            --rarity-orange: #FFA500;
            --rarity-purple: #800080;
            --rarity-blue: #0000FF;
            --rarity-green: #008000;
            --rarity-white: #FFFFFF;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            pointer-events: all;
        }

        #background {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #skillTree {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Base node styles */
        .node {
            position: absolute;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 3px;
            font-size: 12px;
            word-wrap: break-word;
            overflow: visible;
            background-clip: padding-box;
            z-index: 1;

            /* double clicking won't highlight text inside node */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Star shape with outline */
        .node.fundamental {
            width: 110px;
            height: 90px;
            background-clip: padding-box;
            position: relative;
        }

        .node.fundamental::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            clip-path: polygon(50% 0%,
                    61% 35%,
                    98% 35%,
                    68% 57%,
                    79% 91%,
                    50% 70%,
                    21% 91%,
                    32% 57%,
                    2% 35%,
                    39% 35%);
            z-index: -1;
        }


        /* Diamond shape */
        .node.major {
            width: 70px;
            height: 70px;
        }

        .node.major::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            z-index: -1;
        }

        /* Circle shape */
        .node.minor {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: visible;
            /* Allow outline to be visible */
        }

        /* Update inner container for circle */
        .node.minor::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            z-index: -1;
        }

        /* Add specific styling for minor node's inner container */
        .node.minor>div {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            /* Make inner content round too */
            overflow: hidden;
            /* Keep text inside circle */
            margin: 0;
            /* Remove any margin */
            padding: 0;
            /* Remove any padding */
        }

        /* Square shape */
        .node.keystone {
            width: 63px;
            height: 65px;
        }

        .node.keystone::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            z-index: -1;
        }

        /* Heart shape */
        .node.project {
            width: 100px;
            height: 100px;
            position: absolute;
            overflow: visible;
        }

        .node.project::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 2px;
            right: -2px;
            bottom: -2px;
            /* Heart shape clip path */
            clip-path: path('M50,90 C25,70 0,50 0,20 C0,9 10,0 25,0 C35,0 45,10 50,20 C55,10 65,0 75,0 C90,0 100,9 100,20 C100,50 75,70 50,90');
            z-index: -1;
        }

        .node.project > div {
            width: calc(100% - 8px); /* Slightly smaller than the outline */
            height: calc(100% - 8px);
            margin: 4px; 
            padding-bottom: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Use slightly smaller heart for inner content */
            clip-path: path('M50,85 C28,67 5,48 5,20 C5,10 15,2 28,2 C37,2 45,10 50,20 C55,10 63,2 72,2 C85,2 95,10 95,20 C95,48 72,67 50,85');
            position: relative;
            white-space: pre-line; /* Allow line breaks */
        }
        
        .node.project > div > div {
            transform: translateY(-100%);
        }


        .node-content-locked {
            font-size: 14px;
            content: '🔒';
            /* Lock emoji */
        }

        .node-content-unknown {
            font-size: 14px;
            content: '?';
        }

        /* Rarity colors */
        .node.rarity-gold::before {
            background-color: var(--rarity-gold);
        }

        .node.rarity-orange::before {
            background-color: var(--rarity-orange);
        }

        .node.rarity-purple::before {
            background-color: var(--rarity-purple);
        }

        .node.rarity-blue::before {
            background-color: var(--rarity-blue);
        }

        .node.rarity-green::before {
            background-color: var(--rarity-green);
        }

        .node.rarity-white::before {
            background-color: var(--rarity-white);
        }

        .node-creation-dialog {
            position: absolute;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 15px;
            min-width: 250px;
            color: white;
            z-index: 1000;
            transform: translate(-50%, -50%);
        }

        .dialog-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #666;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .form-group select,
        .form-group input {
            /* width: 100%;             */
            width: -webkit-fill-available;            
            padding: 8px;
            background: #333;
            border: 1px solid #666;
            border-radius: 4px;
            color: white;
        }

        .form-group text {
            
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .dialog-buttons button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #4a90e2;
            color: white;
        }

        .dialog-buttons button:last-child {
            background: #666;
        }

        .dialog-buttons button:hover {
            opacity: 0.9;
        }

        .edge {
            position: absolute;
            background: #4a90e2;
            height: 4px;
            /* Made thicker */
            pointer-events: none;
            transition: all 0.3s;
            transform-origin: left center;
            z-index: 2;
            /* Added to ensure edges appear under nodes */
        }

        .edge::after {
            content: '';
            position: absolute;
            right: -8px;
            top: -6px;
            /* Adjusted for thicker line */
            width: 0;
            height: 0;
            border-left: 12px solid #4a90e2;
            /* Made arrow bigger */
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
        }

        .edge.active {
            background: #00ff00;
        }

        .edge.active::after {
            border-left-color: #00ff00;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        #stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            width: 350px;
        }

        /* Add these styles */
        #legend, #rarity-legend {
            margin-top: 20px;
            padding: 10px 15px; /* Reduced right padding */
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        .legend-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
        }

        .count {
            margin-left: auto;
            padding-left: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            justify-content: flex-start;
            white-space: nowrap;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Grid styles */
        /* .grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: -2;
        }

        .grid-line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        } */

        /* Add these styles to your existing CSS */
        .gauge-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .gauge-label {
            width: 30px;
            font-size: 14px;
            color: white;
        }

        .gauge-track {
            flex: 1;
            height: 24px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            z-index: 2;
        }

        .gauge-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
            z-index: 2;
        }

        .gauge-value {
            width: 64px;
            text-align: right;
            font-size: 14px;
        }

        /* Circular gauge styles */
        .total-gauges-container {
            position: relative;
            display: flex;
            justify-content: flex-start;
            margin: 30px 0;
            padding: 25px 20px 35px 20px; 
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-height: 150px; 
            width: fit-content;
        }

        .circular-gauge {
            position: relative;
            width: 120px;
            height: 120px;
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
            margin-bottom: 30px;
        }

        .gauge-circle {
            transform: rotate(-180deg);
            fill: none;
            stroke-width: 8;
        }

        .gauge-circle-bg {
            stroke: #333;
        }

        .gauge-circle-fill {
            stroke-linecap: round;
            transition: stroke-dasharray 0.3s ease;
            transform-origin: center;
        }

        .gauge-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 100%;
            color: white;
        }

        .gauge-percent {
            font-size: 24px;
            font-weight: bold;
        }

        .gauge-count {
            font-size: 12px;
            margin-top: 5px;
        }

        .gauge-label {
            position: relative;
            margin-top: 8px;
            font-size: 14px;
            color: white;
        }

        .collections-container {
            display: grid;
            /* grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); */
            grid-template-columns: repeat(16, 120px); /* Show 10 items per row */
            gap: 70px 20px;
            padding: 0 15px;

            /* display: flex;
            flex-direction: row; 
            justify-content: space-around; */
            width: fit-content;
        }

        .collection-details {
            position: absolute;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 4px;
            z-index: 10;
        }

        .collection-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }

        .status-icon {
            color: var(--status-color, white);
        }

        .collection-item .status-icon[data-active="true"] {
            --status-color: #00ff00;
        }

        .collection-item .status-icon[data-active="false"] {
            --status-color: #ff0000;
        }

    </style>
</head>

<body>
    <div id="container">
        <div id="skillTree"></div>
        <div id="stats">
            <div>Active Nodes: <span id="activeNodes">0</span> / <span id="totalNodes">0</span> (<span id="activeNodesPercent">0%</span>)</div>
            <div>Active Edges: <span id="activeEdges">0</span> / <span id="totalEdges">0</span> (<span id="activeEdgesPercent">0%</span>)</div>

            <div class="total-gauges-container">
                <div class="circular-gauge" id="totalDomainGauge"></div>
                <div class="collections-container" id="collectionsContainer"></div>
            </div>

            <div id="legend">
                <div class="legend-title">Domains:</div>
                <!-- Gauge bars will be inserted here -->
            </div>
            <div id="rarity-legend">
                <div class="legend-title">Rarities:</div>
                <!-- Gauge bars will be inserted here -->
            </div>
        </div>
        <div id="controls">
            <button id="zoomIn">+</button>
            <button id="zoomOut">-</button>
            <button id="fitScreen">Fit Screen</button>
        </div>
    </div>
    <script>
        class SkillTree {
            constructor(containerId, data) {
                this.container = document.getElementById(containerId);
                this.data = data;
                this.scale = 1;
                this.dragStart = {
                    x: 0,
                    y: 0
                };
                this.offset = {
                    x: 0,
                    y: 0
                };
                this.activeNodes = new Set();
                this.activeEdges = new Set();

                this.showGrid = true; 

                // Extract node types dynamically from data
                this.nodeTypes = Object.keys(data.nodes).map(type => ({
                    id: type,
                    label: type.charAt(0).toUpperCase() + type.slice(1) // Capitalize first letter
                }));

                // Load domains with their labels and colors from data
                this.domains = {};
                Object.entries(data.domains).forEach(([id, color]) => {
                    this.domains[id] = {
                        color: color,
                        label: data.domainLabels?.[id] || id // Use label from JSON if available, otherwise use ID
                    };
                });

                // Load rarities from data
                this.rarities = {};
                Object.entries(data.rarities).forEach(([id, info]) => {
                    this.rarities[id] = {
                        color: info.color,
                        label: info.label
                    };
                });

                // Initialize lastNodeId
                this.lastNodeId = this.initializeLastNodeId();

                // this.data.domains = {
                //     "learn": "#4A90E2",
                //     "computer-science": "#F5A623",
                //     "web-development": "#7ED321",
                //     "math": "#BD10E0",
                //     "machine-learning": "#FF5733"
                // };

                this.activeCollections = new Set(); 
                this.isCreatingNode = false;
                this.newNodePosition = { x: 0, y: 0 };

                this.init();
            }

            initializeLastNodeId() {
                let maxId = 0;
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                
                allNodes.forEach(node => {
                    // Convert existing IDs to numbers
                    if (node.id) {
                        const oldId = node.id;
                        maxId++;
                        const newId = maxId;
                        
                        // Update the node's ID
                        node.id = newId;
                        
                        // Update any connections that reference this node
                        allNodes.forEach(otherNode => {
                            if (otherNode.connections) {
                                otherNode.connections = otherNode.connections.map(conn => 
                                    conn === oldId ? newId : conn
                                );
                            }
                        });

                        // Update collections
                        if (this.data.collections) {
                            Object.values(this.data.collections).forEach(collection => {
                                collection.nodes = collection.nodes.map(nodeId =>
                                    nodeId === oldId ? newId : nodeId
                                );
                            });
                        }
                    }
                });
                return maxId;
            }

            // createGrid() {
            //     const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            //     svg.classList.add('grid');
            //     svg.setAttribute('width', '100%');
            //     svg.setAttribute('height', '100%');

            //     // Create grid lines
            //     const gridSize = 50;
            //     const width = this.container.clientWidth;
            //     const height = this.container.clientHeight;

            //     // Vertical lines
            //     for (let x = 0; x <= width; x += gridSize) {
            //         const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            //         line.setAttribute('x1', x);
            //         line.setAttribute('y1', 0);
            //         line.setAttribute('x2', x);
            //         line.setAttribute('y2', height);
            //         line.classList.add('grid-line');
            //         svg.appendChild(line);
            //     }

            //     // Horizontal lines
            //     for (let y = 0; y <= height; y += gridSize) {
            //         const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            //         line.setAttribute('x1', 0);
            //         line.setAttribute('y1', y);
            //         line.setAttribute('x2', width);
            //         line.setAttribute('y2', y);
            //         line.classList.add('grid-line');
            //         svg.appendChild(line);
            //     }

            //     this.container.appendChild(svg);
            //     this.gridElement = svg;
            // }

            isEdgeActive(edge) {
                const sourceNode = this.findNodeData(edge.source);
                const targetNode = this.findNodeData(edge.target);
                return sourceNode.explored && targetNode.explored;
            }

            init() {
                this.setupContainer();
                // this.createGrid();

                // Initialize active nodes first
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                allNodes.forEach(nodeData => {
                    if (nodeData.explored) {
                        this.activeNodes.add(nodeData.id);
                    }
                });

                this.createNodes();
                this.createEdges();
                this.setupEventListeners();
                this.updateStats();
            }

            setupContainer() {
                this.container.style.transform = `scale(${this.scale})
            translate(${this.offset.x}px, ${this.offset.y}px)`;
            }

            createNodes() {
                // Create nodes for each type
                Object.entries(this.data.nodes).forEach(([type, nodes]) => {
                    if (Array.isArray(nodes)) {
                        nodes.forEach(node => this.createNode(node));
                    } else {
                        this.createNode(nodes);
                    }
                });
            }

            createNode(nodeData) {
                const node = document.createElement('div');
                node.className = `node ${nodeData.type}`;

                // Add rarity class
                if (nodeData.rarity) {
                    node.classList.add(`rarity-${nodeData.rarity}`);
                } else {
                    node.classList.add('rarity-white'); // default rarity
                }

                // Convert numeric ID to string for HTML element ID
                node.id = String(nodeData.id);;

                // Position nodes using absolute positioning
                node.style.left = `${nodeData.position.x}px`;
                node.style.top = `${nodeData.position.y}px`;

                this.updateNodeDisplay(node, nodeData);
                this.container.appendChild(node);
            }

            isNodeAccessible(nodeId) {
                const nodeData = this.findNodeData(nodeId);

                // Check incoming connections
                const hasActiveIncomingConnection = Object.values(this.data.nodes)
                    .flat()
                    .filter(node => node)
                    .some(node =>
                        node.connections &&
                        node.connections.includes(nodeData.title) &&
                        this.activeNodes.has(node.id)
                    );

                // Check outgoing connections
                const hasActiveOutgoingConnection = nodeData.connections &&
                    nodeData.connections.some(targetTitle => {
                        const targetNode = this.findNodeByTitle(targetTitle);
                        return targetNode && this.activeNodes.has(targetNode.id);
                    });

                return hasActiveIncomingConnection || hasActiveOutgoingConnection;
            }

            updateNodeDisplay(node, nodeData) {
                // Clear current content
                node.innerHTML = '';

                // Create inner container
                const innerContainer = document.createElement('div');
                innerContainer.style.width = '100%';
                innerContainer.style.height = '100%';
                innerContainer.style.display = 'flex';
                innerContainer.style.alignItems = 'center';
                innerContainer.style.justifyContent = 'center';
                innerContainer.style.clipPath = this.getClipPath(nodeData.type);

                if (nodeData.explored) {
                    // Active node
                    innerContainer.style.backgroundColor = this.data.domains[nodeData.domain];
                    this.createTextContainer(innerContainer, nodeData.title); 
                } else {
                    // Inactive node
                    innerContainer.style.backgroundColor = '#333';
                    if (this.isNodeAccessible(nodeData.id)) {
                        innerContainer.textContent = '?';
                    } else {
                        innerContainer.textContent = '🔒';
                    }
                }

                node.appendChild(innerContainer);
            }

            startNodeCreation(e) {
                const rect = this.container.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.scale - this.offset.x;
                const y = (e.clientY - rect.top) / this.scale - this.offset.y;
                
                this.isCreatingNode = true;
                this.newNodePosition = { x, y };
                this.showNodeCreationDialog(x, y);
            }

            showNodeCreationDialog(x, y) {
                const existingDialog = document.querySelector('.node-creation-dialog');
                if (existingDialog) existingDialog.remove();

                const dialog = document.createElement('div');
                dialog.className = 'node-creation-dialog';
                dialog.style.left = `${x}px`;
                dialog.style.top = `${y}px`;

                // Use an instance method instead of onclick attribute
                const createNewNodeHandler = () => {
                    this.createNewNode();
                };

                const cancelCreationHandler = () => {
                    this.cancelNodeCreation();
                };

                dialog.innerHTML = `
                    <div class="dialog-header">Create New Node</div>
                    <div class="dialog-content">
                        <div class="form-group">
                            <label>Shape:</label>
                            <select id="nodeType">
                                ${this.nodeTypes.map(type => 
                                    `<option value="${type.id}">${type.label}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Domain:</label>
                            <select id="nodeDomain">
                                ${Object.entries(this.domains).map(([id, info]) => 
                                    `<option value="${id}">${info.label}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Rarity:</label>
                            <select id="nodeRarity">
                                ${Object.entries(this.rarities).map(([id, info]) => 
                                    `<option value="${id}">${info.label}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Title:</label>
                            <input type="text" id="nodeTitle" placeholder="Enter node title">
                        </div>
                        <div class="dialog-buttons">
                            <button id="createNodeBtn">Create</button>
                            <button id="cancelNodeBtn">Cancel</button>
                        </div>
                    </div>
                `;

                this.container.appendChild(dialog);

                // Add event listeners after appending to DOM
                document.addEventListener('keydown', this.handleEscKey);
                document.getElementById('createNodeBtn').addEventListener('click', createNewNodeHandler);
                document.getElementById('cancelNodeBtn').addEventListener('click', cancelCreationHandler);
                document.addEventListener('keydown', this.handleEscKey);
            }

            // Add method to handle ESC key
            handleEscKey = (e) => {
                if (e.key === 'Escape') {
                    this.cancelNodeCreation();
                }
            }

            // Add method to cancel node creation
            cancelNodeCreation() {
                this.isCreatingNode = false;
                const dialog = document.querySelector('.node-creation-dialog');
                if (dialog) dialog.remove();
                document.removeEventListener('keydown', this.handleEscKey);
            }

            // Add method to create new node
            createNewNode() {
                const type = document.getElementById('nodeType').value;
                const domain = document.getElementById('nodeDomain').value;
                const rarity = document.getElementById('nodeRarity').value;
                const title = document.getElementById('nodeTitle').value;

                if (!title) {
                    alert('Please enter a title for the node');
                    return;
                }

                // Increment lastNodeId for new numeric ID
                this.lastNodeId++;

                // Create new node data
                const newNode = {
                    id: this.lastNodeId,
                    type: type,
                    domain: domain,
                    position: this.newNodePosition,
                    title: title,
                    explored: false,
                    connections: [],
                    rarity: rarity
                };

                // Add to appropriate node type array in data
                if (!Array.isArray(this.data.nodes[type])) {
                    this.data.nodes[type] = [];
                }
                this.data.nodes[type].push(newNode);

                // Create the node in the UI
                this.createNode(newNode);

                // Update statistics
                this.updateStats();

                // Close dialog
                this.cancelNodeCreation();
            }

            getClipPath(type) {
                switch (type) {
                    case 'fundamental':
                        return 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
                    case 'major':
                        return 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                    case 'minor':
                        return 'circle(50%)';
                    case 'keystone':
                        return 'none';
                    case 'project':
                        return 'path("M45,85 C23,67 0,48 0,20 C0,10 10,2 23,2 C32,2 40,10 45,20 C50,10 58,2 67,2 C80,2 90,10 90,20 C90,48 67,67 45,85")';
                    default:
                        return 'none';
                }
            }

            createTextContainer(container, text) {
                if (!container || !text) return; // Add safety check

                const textWrapper = document.createElement('div');
                textWrapper.style.width = '80%';
                textWrapper.style.display = 'flex';
                textWrapper.style.flexDirection = 'column';
                textWrapper.style.alignItems = 'center';
                textWrapper.style.justifyContent = 'center';
                textWrapper.style.wordBreak = 'break-word';
                textWrapper.style.textAlign = 'center';
                textWrapper.style.whiteSpace = 'pre-line';


                // Safe check for parent element and its class
                const nodeType = container.parentElement ? container.parentElement.className.split(' ')[1] : '';

                // Specific adjustments based on node type
                switch(nodeType) {
                    case 'project':
                        break;
                    case 'fundamental':
                        textWrapper.style.width = '70%';
                        break;
                    case 'major':
                        textWrapper.style.width = '75%';
                        break;
                }

                // Rest of the method remains the same...
                if (text.length > 20) {
                    textWrapper.style.fontSize = '8px';
                } else if (text.length > 15) {
                    textWrapper.style.fontSize = '9px';
                } else if (text.length > 10) {
                    textWrapper.style.fontSize = '10px';
                } else {
                    textWrapper.style.fontSize = '11px';
                }

                // Line break logic
                const words = text.split(' ');
                let line = '';
                let lines = [];
                
                // Set threshold based on node type
                let threshold = 12; // default
                switch(nodeType) {
                    case 'fundamental':
                        threshold = 15;
                        break;
                    case 'minor':
                        threshold = 10;
                        break;
                }

                words.forEach(word => {
                    if (line.length + word.length > threshold) {
                        lines.push(line);
                        line = word;
                    } else {
                        line = line ? line + ' ' + word : word;
                    }
                });
                if (line) {
                    lines.push(line);
                }

                textWrapper.textContent = lines.join('\n');
                container.appendChild(textWrapper);
            }

            createEdges() {
                // Get all nodes in a flat array
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);

                // Create edges from connections
                allNodes.forEach(node => {
                    if (node.connections) {
                        node.connections.forEach(targetTitle => {
                            const targetNode = this.findNodeByTitle(targetTitle);
                            if (targetNode) {
                                const edgeElement = document.createElement('div');
                                edgeElement.className = 'edge';
                                this.updateEdgePosition(edgeElement, node.id, targetNode.id);
                                edgeElement.dataset.source = node.id;
                                edgeElement.dataset.target = targetNode.id;
                                this.container.appendChild(edgeElement);

                                if (node.explored && targetNode.explored) {
                                    this.activeEdges.add(`${node.id}-${targetNode.id}`);
                                    edgeElement.classList.add('active');
                                }
                            }
                        });
                    }
                });
            }

            updateEdgePosition(edgeElement, sourceId, targetId) {
                const source = document.getElementById(sourceId);
                const target = document.getElementById(targetId);

                if (!source || !target) return;

                // Get nodes' positions directly from the stored data
                const sourceData = this.findNodeData(sourceId);
                const targetData = this.findNodeData(targetId);

                if (!sourceData || !targetData) return;

                // Use stored positions for calculations
                const sourceX = sourceData.position.x + source.offsetWidth / 2;
                const sourceY = sourceData.position.y + source.offsetHeight / 2;
                const targetX = targetData.position.x + target.offsetWidth / 2;
                const targetY = targetData.position.y + target.offsetHeight / 2;

                // Calculate angle for the edge
                const dx = targetX - sourceX;
                const dy = targetY - sourceY;
                const angle = Math.atan2(dy, dx);

                // Get node radii (half of width for simplicity)
                const sourceRadius = source.offsetWidth / 2;
                const targetRadius = target.offsetWidth / 2;

                // Calculate edge start and end points at node boundaries
                const startX = sourceX + sourceRadius * Math.cos(angle);
                const startY = sourceY + sourceRadius * Math.sin(angle);
                const endX = targetX - targetRadius * Math.cos(angle);
                const endY = targetY - targetRadius * Math.sin(angle);

                // Calculate length
                const length = Math.sqrt(
                    Math.pow(endX - startX, 2) +
                    Math.pow(endY - startY, 2)
                );

                // Update edge element position and rotation
                edgeElement.style.width = `${length}px`;
                edgeElement.style.left = `${startX}px`;
                edgeElement.style.top = `${startY}px`;
                edgeElement.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
            }

            updateConnectedEdges(nodeId) {
                // Update edges where this node is the source
                const outgoingEdges = Array.from(this.container.getElementsByClassName('edge'))
                    .filter(edge => edge.dataset.source === nodeId);
                
                outgoingEdges.forEach(edge => {
                    this.updateEdgePosition(edge, edge.dataset.source, edge.dataset.target);
                });

                // Update edges where this node is the target
                const incomingEdges = Array.from(this.container.getElementsByClassName('edge'))
                    .filter(edge => edge.dataset.target === nodeId);
                
                incomingEdges.forEach(edge => {
                    this.updateEdgePosition(edge, edge.dataset.source, edge.dataset.target);
                });
            }

            setupEventListeners() {
                //debug purpose code, find detailed info on clicked DOM element
                // this.container.parentElement.addEventListener('click', (e) => {
                //     alert("clicked!!!!");
                //     console.log('Clicked element:', e.target);
                //     console.log('Clicked element tag:', e.target.tagName);
                //     console.log('Clicked element class:', e.target.className);
                //     console.log('Container element:', this.container);
                    
                //     // Log the entire path from clicked element up to document
                //     let element = e.target;
                //     let path = [];
                //     while (element) {
                //         path.push({
                //             tag: element.tagName,
                //             id: element.id,
                //             class: element.className
                //         });
                //         element = element.parentElement;
                //     }
                //     console.log('DOM Path:', path);
                // });

                // feat1: Node click handling to toggle on/off
                this.container.addEventListener('click', (e) => {
                    const node = e.target.closest('.node');
                    if (node) {
                        this.toggleNode(node);
                    }
                });

                //feat2: Node dragging & background dragging
                let draggedNode = null;
                let dragOffset = { x: 0, y: 0 };
                let isNodeDragging = false;
                let initialNodePosition = { x: 0, y: 0 };

                // Background panning
                let isBackgroundDragging = false;
                let startX, startY;

                // Node dragging handlers
                this.container.addEventListener('mousedown', (e) => {
                    const node = e.target.closest('.node');
                    if (node) {
                        e.stopPropagation(); // Prevent background drag when dragging node
                        draggedNode = node;
                        isNodeDragging = true;
                        
                        // Store initial mouse position and node position
                        const nodeData = this.findNodeData(node.id);
                        initialNodePosition = {
                            x: nodeData.position.x,
                            y: nodeData.position.y
                        };
                        
                        dragOffset = {
                            x: e.clientX,
                            y: e.clientY
                        };
                    }
                });

                // Background panning handlers
                window.addEventListener('mousedown', (e) => {
                    // Only start background drag if not clicking a node
                    if (!e.target.closest('.node')) {
                        isBackgroundDragging = true;
                        startX = e.clientX - this.offset.x;
                        startY = e.clientY - this.offset.y;
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    // Node dragging
                    if (isNodeDragging && draggedNode) {
                        e.preventDefault();
                        
                        // Calculate the movement delta
                        const dx = (e.clientX - dragOffset.x) / this.scale;
                        const dy = (e.clientY - dragOffset.y) / this.scale;
                        
                        // Calculate new position based on initial position plus delta
                        const newX = initialNodePosition.x + dx;
                        const newY = initialNodePosition.y + dy;
                        
                        // Update node position
                        draggedNode.style.left = `${newX}px`;
                        draggedNode.style.top = `${newY}px`;

                        // Update node data
                        const nodeId = draggedNode.id;
                        const nodeData = this.findNodeData(nodeId);
                        if (nodeData) {
                            nodeData.position.x = Math.round(newX);
                            nodeData.position.y = Math.round(newY);
                        }

                        // Update connected edges
                        this.updateConnectedEdges(nodeId);
                    }
                    
                    // Background panning
                    if (isBackgroundDragging && !isNodeDragging) {
                        this.offset.x = e.clientX - startX;
                        this.offset.y = e.clientY - startY;
                        this.updateTransform();
                    }
                });

                window.addEventListener('mouseup', () => {
                    draggedNode = null;
                    isNodeDragging = false;
                    isBackgroundDragging = false;
                });


                // feat3: Zooming
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.scale *= 1.2;
                    this.updateTransform();
                });

                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.scale /= 1.2;
                    this.updateTransform();
                });

                document.getElementById('fitScreen').addEventListener('click', () => {
                    this.fitToScreen();
                });

                // Mouse wheel zooming
                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= delta;
                    this.updateTransform();
                });

                // feat4: create new node 
                // Add double click handler for node creation
                this.container.parentElement.addEventListener('dblclick', (e) => {
                    const isSkillTree = e.target.closest('#skillTree');
                    const isStats = e.target.closest('#stats');
                    const isControls = e.target.closest('#controls');
                    const isDialog = e.target.closest('.node-creation-dialog');

                    // Only proceed if we're not clicking any of these elements
                    if (!isSkillTree && !isStats && !isControls && !isDialog) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startNodeCreation(e);
                    }
                });
            }

            toggleNode(node) {
                const nodeId = parseInt(node.id); // Convert to number since DOM IDs are strings
                const nodeData = this.findNodeData(nodeId);
                
                if (!nodeData) return;
                
                // Update the explored status in the node data
                nodeData.explored = !nodeData.explored;
                
                if (nodeData.explored) {
                    this.activateNode(node);
                } else {
                    this.deactivateNode(node);
                }
                
                this.updateStats();
            }

            activateNode(node) {
                const nodeId = parseInt(node.id);
                const nodeData = this.findNodeData(nodeId);
                if (!nodeData) return;                

                this.activeNodes.add(nodeId);
                nodeData.explored = true;
                this.updateNodeDisplay(node, nodeData);

                // Update edges for outgoing connections
                nodeData.connections?.forEach(targetTitle => {
                        const targetNode = this.findNodeByTitle(targetTitle);
                        if (targetNode && this.activeNodes.has(targetNode.id)) {
                            this.activeEdges.add(`${nodeId}-${targetNode.id}`);
                            const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                                .find(el =>
                                    (el.dataset.source === String(nodeId) && el.dataset.target === String(targetNode.id)) ||
                                    (el.dataset.source === String(targetNode.id) && el.dataset.target === String(nodeId))
                                );
                            if (edgeElement) edgeElement.classList.add('active');
                        }
                    });

                // Update edges for incoming connections
                Object.values(this.data.nodes)
                    .flat()
                    .filter(n => n && n.connections?.includes(nodeData.title))
                    .forEach(sourceNode => {
                        if (this.activeNodes.has(sourceNode.id)) {
                            this.activeEdges.add(`${sourceNode.id}-${nodeId}`);
                            const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                                .find(el =>
                                    (el.dataset.source === String(sourceNode.id) && el.dataset.target === String(nodeId)) ||
                                    (el.dataset.source === String(nodeId) && el.dataset.target === String(sourceNode.id))
                                );
                            if (edgeElement) edgeElement.classList.add('active');
                        }
                    });

                this.updateConnectedNodesDisplay(nodeId);
            }

            deactivateNode(node) {
                const nodeId = parseInt(node.id); // Convert to number if it's a string
                const nodeData = this.findNodeData(nodeId);

                if (!nodeData) return;

                this.activeNodes.delete(nodeId);
                nodeData.explored = false;
                this.updateNodeDisplay(node, nodeData);

                // Update edges for outgoing connections
                nodeData.connections?.forEach(targetTitle => {
                    const targetNode = this.findNodeByTitle(targetTitle);
                    if (targetNode) {
                        this.activeEdges.delete(`${nodeId}-${targetNode.id}`);
                        const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                            .find(el =>
                                (el.dataset.source === String(nodeId) && el.dataset.target === String(targetNode.id)) ||
                                (el.dataset.source === String(targetNode.id) && el.dataset.target === String(nodeId))
                            );
                        if (edgeElement) edgeElement.classList.remove('active');
                    }
                });

                // Update edges for incoming connections
                Object.values(this.data.nodes)
                    .flat()
                    .filter(n => n && n.connections?.includes(nodeData.title))
                    .forEach(sourceNode => {
                        this.activeEdges.delete(`${sourceNode.id}-${nodeId}`);
                        const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                            .find(el =>
                                (el.dataset.source === String(sourceNode.id) && el.dataset.target === String(nodeId)) ||
                                (el.dataset.source === String(nodeId) && el.dataset.target === String(sourceNode.id))
                            );
                        if (edgeElement) edgeElement.classList.remove('active');
                    });

                this.updateConnectedNodesDisplay(nodeId);
            }

            updateConnectedNodesDisplay(nodeId) {
                const nodeData = this.findNodeData(nodeId);

                // Update nodes that this node connects to (outgoing connections)
                if (nodeData.connections) {
                    nodeData.connections.forEach(targetTitle => {
                        const targetNodeData = this.findNodeByTitle(targetTitle);
                        if (targetNodeData) {
                            const targetElement = document.getElementById(targetNodeData.id);
                            if (targetElement) {
                                this.updateNodeDisplay(targetElement, targetNodeData);
                            }
                        }
                    });
                }

                // Update nodes that connect to this node (incoming connections)
                Object.values(this.data.nodes)
                    .flat()
                    .filter(node => node && node.connections && node.connections.includes(nodeData.title))
                    .forEach(sourceNode => {
                        const sourceElement = document.getElementById(sourceNode.id);
                        if (sourceElement) {
                            this.updateNodeDisplay(sourceElement, sourceNode);
                        }
                    });
            }

            updateEdgeStyle(edge) {
                const edgeId = `${edge.source}-${edge.target}`;
                const edgeElement = this.findEdgeElement(edge);
                if (edgeElement) {
                    if (this.activeEdges.has(edgeId)) {
                        edgeElement.classList.add('active');
                    } else {
                        edgeElement.classList.remove('active');
                    }
                }
            }

            findNodeData(nodeId) {
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                // Convert string ID from DOM to number if needed
                const numericId = typeof nodeId === 'string' ? parseInt(nodeId) : nodeId;
                return allNodes.find(node => node.id === numericId);
            }

            findNodeByTitle(title) {
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                return allNodes.find(node => node.title === title);
            }

            findNodeIdByTitle(title) {
                const node = this.findNodeByTitle(title);
                return node ? node.id : null;
            }

            findEdgeElement(edge) {
                return Array.from(this.container.getElementsByClassName('edge'))
                    .find(el =>
                        el.dataset.source === edge.source &&
                        el.dataset.target === edge.target
                    );
            }

            updateTransform() {
                if (this.container) {
                    this.container.style.transform =
                        `translate(${this.offset.x}px, ${this.offset.y}px) scale(${this.scale})`;
                }
            }

            fitToScreen() {
                // Get root node and all nodes
                const rootNode = document.getElementById('root');
                const nodes = Array.from(this.container.getElementsByClassName('node'));
                if (!rootNode || nodes.length === 0) return;

                // First, center on root node
                const containerRect = this.container.parentElement.getBoundingClientRect();
                const containerCenterX = containerRect.width / 2;
                const containerCenterY = containerRect.height / 2;

                // Reset scale initially
                this.scale = 1;
                this.updateTransform();

                // Get root node position
                const rootRect = rootNode.getBoundingClientRect();
                const rootCenterX = rootRect.left + (rootRect.width / 2);
                const rootCenterY = rootRect.top + (rootRect.height / 2);

                // Center on root
                this.offset.x = containerCenterX - rootCenterX;
                this.offset.y = containerCenterY - rootCenterY;
                this.updateTransform();

                // Now find the bounds of all nodes
                let minX = Infinity,
                    maxX = -Infinity;
                let minY = Infinity,
                    maxY = -Infinity;

                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    minX = Math.min(minX, rect.left);
                    maxX = Math.max(maxX, rect.right);
                    minY = Math.min(minY, rect.top);
                    maxY = Math.max(maxY, rect.bottom);
                });

                // Calculate required scale with padding
                const padding = 50;
                const width = maxX - minX + (padding * 2);
                const height = maxY - minY + (padding * 2);

                const scaleX = containerRect.width / width;
                const scaleY = containerRect.height / height;
                this.scale = Math.min(scaleX, scaleY);

                // Update one final time with new scale
                this.updateTransform();
            }

            createGaugeBar(container, label, percentage, color, count, total) {
                const gaugeBar = document.createElement('div');
                gaugeBar.className = 'gauge-bar';
                
                const labelEl = document.createElement('span');
                labelEl.className = 'gauge-label';
                labelEl.textContent = label;
                labelEl.style.color = color; 
                
                const track = document.createElement('div');
                track.className = 'gauge-track';
                
                const fill = document.createElement('div');
                fill.className = 'gauge-fill';
                fill.style.width = `${percentage}%`;
                fill.style.backgroundColor = color;
                
                const value = document.createElement('span');
                value.className = 'gauge-value';
                value.style.color = color;
                value.textContent = `${percentage.toFixed(1)}%`;
                
                track.appendChild(fill);
                gaugeBar.appendChild(labelEl);
                gaugeBar.appendChild(track);
                gaugeBar.appendChild(value);
                
                container.appendChild(gaugeBar);
            }

            createCircularGauge(container, percentage, color, count, total, label, isCollection = false, collectionId = null) {
                container.innerHTML = '';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 100 100');
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.transform = 'rotate(-90deg)'; // Rotate the SVG
                
                // Background circle
                const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgCircle.setAttribute('cx', '50');
                bgCircle.setAttribute('cy', '50');
                bgCircle.setAttribute('r', '45');
                // bgCircle.className = 'gauge-circle gauge-circle-bg';
                // Fix: Use setAttribute for SVG classes
                bgCircle.setAttribute('class', 'gauge-circle gauge-circle-bg');

                    
                // Progress circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '50');
                circle.setAttribute('cy', '50');
                circle.setAttribute('r', '45');
                // circle.className = 'gauge-circle gauge-circle-fill';
                // Fix: Use setAttribute for SVG classes
                bgCircle.setAttribute('class', 'gauge-circle gauge-circle-fill');
                circle.style.stroke = color;
                
                const circumference = 2 * Math.PI * 45;
                const fillLength = (percentage / 100) * circumference;

                // Add strokeDashoffset to start from top
                circle.style.strokeDasharray = `${circumference}`;
                circle.style.strokeDashoffset = circumference - fillLength;
                
                svg.appendChild(bgCircle);
                svg.appendChild(circle);
                
                // Add text elements
                const textContainer = document.createElement('div');
                textContainer.className = 'gauge-text';
                
                const percentText = document.createElement('div');
                percentText.className = 'gauge-percent';
                percentText.textContent = `${percentage.toFixed(1)}%`;
                
                const countText = document.createElement('div');
                countText.className = 'gauge-count';
                countText.textContent = `${count} / ${total}`;
                
                textContainer.appendChild(percentText);
                textContainer.appendChild(countText);
                
                const labelText = document.createElement('div');
                labelText.className = 'gauge-label';
                labelText.textContent = label;
                labelText.style.color = color;

                if (isCollection) {
                    container.style.cursor = 'pointer';
                    container.onclick = () => this.toggleCollectionDetails(collectionId);
                }
                
                container.appendChild(svg);
                container.appendChild(textContainer);
                container.appendChild(labelText);
            }

            toggleCollectionDetails(collectionId) {
                if (this.activeCollections.has(collectionId)) {
                    this.activeCollections.delete(collectionId);
                } else {
                    this.activeCollections.add(collectionId);
                }
                this.updateStats(); // Refresh display
            }

            updateStats() {
                // Get total counts first
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                const totalNodes = allNodes.length;
                const totalEdges = allNodes.reduce((count, node) =>
                    count + (node.connections?.length || 0), 0);

                // Count totals by domain and rarity
                const domainTotals = {};
                const rarityTotals = {
                    gold: 0,
                    orange: 0,
                    purple: 0,
                    blue: 0,
                    green: 0,
                    white: 0
                };

                allNodes.forEach(node => {
                    if (node.domain) {
                        domainTotals[node.domain] = (domainTotals[node.domain] || 0) + 1;
                    }
                    const rarity = node.rarity || 'white';
                    rarityTotals[rarity] = (rarityTotals[rarity] || 0) + 1;
                });

                // Update total counts
                document.getElementById('totalNodes').textContent = totalNodes;
                document.getElementById('totalEdges').textContent = totalEdges;
                document.getElementById('activeNodes').textContent = this.activeNodes.size;
                document.getElementById('activeEdges').textContent = this.activeEdges.size;

                // Update percentages
                const activeNodesPercent = ((this.activeNodes.size / totalNodes) * 100).toFixed(1);
                const activeEdgesPercent = ((this.activeEdges.size / totalEdges) * 100).toFixed(1);
                document.getElementById('activeNodesPercent').textContent = `${activeNodesPercent}%`;
                document.getElementById('activeEdgesPercent').textContent = `${activeEdgesPercent}%`;

                // Count active nodes by domain and rarity
                const domainCounts = {};
                const rarityCounts = {
                    gold: 0,
                    orange: 0,
                    purple: 0,
                    blue: 0,
                    green: 0,
                    white: 0
                };

                this.activeNodes.forEach(nodeId => {
                    const nodeData = this.findNodeData(nodeId);
                    if (nodeData) {
                        if (nodeData.domain) {
                            domainCounts[nodeData.domain] = (domainCounts[nodeData.domain] || 0) + 1;
                        }
                        const rarity = nodeData.rarity || 'white';
                        rarityCounts[rarity]++;
                    }
                });

                // Calculate totals for domains and rarities
                const totalDomainCount = Object.values(domainCounts).reduce((a, b) => a + b, 0);
                const totalDomainTotal = Object.values(domainTotals).reduce((a, b) => a + b, 0);
                const totalDomainPercentage = (totalDomainCount / totalDomainTotal) * 100;

                const totalRarityCount = Object.values(rarityCounts).reduce((a, b) => a + b, 0);
                const totalRarityTotal = Object.values(rarityTotals).reduce((a, b) => a + b, 0);
                const totalRarityPercentage = (totalRarityCount / totalRarityTotal) * 100;

                // Update circular gauges for totals
                this.createCircularGauge(
                    document.getElementById('totalDomainGauge'),
                    totalDomainPercentage,
                    '#4A90E2', // Use appropriate color
                    totalDomainCount,
                    totalDomainTotal,
                    'Total Domains'
                );

                // Update domain gauge bars
                const legend = document.getElementById('legend');
                legend.innerHTML = '<div class="legend-title">Domains:</div>';
                Object.entries(this.data.domains).forEach(([domain, color]) => {
                    const active = domainCounts[domain] || 0;
                    const total = domainTotals[domain];
                    const percentage = total > 0 ? (active / total) * 100 : 0;
                    this.createGaugeBar(
                        legend,
                        domain === 'learn' ? '학습' :
                        domain === 'computer-science' ? 'CS' :
                        domain === 'web-development' ? 'Web' :
                        domain === 'math' ? 'Math' :
                        domain === 'machine-learning' ? 'ML' : domain,
                        percentage,
                        color,
                        active,
                        total
                    );
                });

                // Update rarity gauge bars
                const rarityLegend = document.getElementById('rarity-legend');
                rarityLegend.innerHTML = '<div class="legend-title">Rarities:</div>';
                const rarityLabels = {
                    'gold': '초월',
                    'orange': '전설',
                    'purple': '영웅',
                    'blue': '희귀',
                    'green': '일반',
                    'white': '기본'
                };
                Object.entries(rarityTotals).forEach(([rarity, total]) => {
                    const active = rarityCounts[rarity] || 0;
                    const percentage = total > 0 ? (active / total) * 100 : 0;
                    const color = getComputedStyle(document.documentElement)
                        .getPropertyValue(`--rarity-${rarity}`).trim();
                    this.createGaugeBar(rarityLegend, rarityLabels[rarity], percentage, color, active, total);
                });

                // Update circular gauges style
                const style = document.createElement('style');
                style.textContent = `
                    .gauge-circle-bg {
                        stroke: #333;
                        stroke-width: 8;
                    }
                    .gauge-circle-fill {
                        stroke-width: 8;
                        stroke-linecap: round;
                        transform: rotate(-90deg);
                        transform-origin: center;
                        transition: stroke-dasharray 0.3s ease;
                    }
                `;
                document.head.appendChild(style);

                // Update the circular gauges for totals
                if (totalDomainTotal > 0) {
                    this.createCircularGauge(
                        document.getElementById('totalDomainGauge'),
                        totalDomainPercentage,
                        '#4A90E2',
                        totalDomainCount,
                        totalDomainTotal,
                        'Total Domains'
                    );
                }

                const collectionsContainer = document.getElementById('collectionsContainer');
                collectionsContainer.innerHTML = '';

                // Add collection gauges
                Object.entries(this.data.collections || {}).forEach(([collectionId, collection]) => {
                    const collectionGauge = document.createElement('div');
                    collectionGauge.className = 'circular-gauge';

                    // Get domain color for the collection
                    const domainColor = this.data.domains[collection.domain] || '#4A90E2';

                    // Calculate collection progress
                    const totalNodes = collection.nodes.length;
                    const activeNodes = collection.nodes.filter(nodeTitle => {
                        const node = this.findNodeByTitle(nodeTitle);
                        // Convert node.id to number since activeNodes stores numeric IDs
                        return node && this.activeNodes.has(parseInt(node.id));
                    }).length;
                    const percentage = totalNodes > 0 ? (activeNodes / totalNodes) * 100 : 0;

                    // Create gauge
                    this.createCircularGauge(
                        collectionGauge,
                        percentage,
                        domainColor,
                        activeNodes,
                        totalNodes,
                        collection.title,
                        true,
                        collectionId
                    );

                    // Add collection details if expanded
                    if (this.activeCollections.has(collectionId)) {
                        const details = document.createElement('div');
                        details.className = 'collection-details';
                        
                        collection.nodes.forEach(nodeId => {
                            const node = this.findNodeByTitle(nodeId); 
                            if (node) {
                                const item = document.createElement('div');
                                item.className = 'collection-item';
                                const isActive = this.activeNodes.has(parseInt(node.id));
                                item.innerHTML = `
                                    <span class="status-icon" style="color: ${isActive ? '#00ff00' : '#ff0000'}">${isActive ? '✓' : '×'}</span>
                                    <span class="node-title">${node.title}</span>
                                `;
                                details.appendChild(item);
                            }
                        });
                        
                        collectionGauge.appendChild(details);
                    }

                    collectionsContainer.appendChild(collectionGauge);
                });
            }

            // Add method to toggle grid
            // toggleGrid() {
            //     this.showGrid = !this.showGrid;
            //     const grid = this.container.querySelector('.grid');
            //     if (grid) {
            //         grid.style.display = this.showGrid ? 'block' : 'none';
            //     }
            // }
        }

        let skillTree;

        fetch('skill-tree.json')
            .then(response => response.json())
            .then(data => {
                skillTree = new SkillTree('skillTree', data);
            });
    </script>
</body>

</html>