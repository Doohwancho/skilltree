<!DOCTYPE html>
<html>

<head>
    <title>Skill Tree Visualization</title>
    <style id="dynamicStyles">
        /* Define rarity colors */
        :root {
            --rarity-gold: #FFD700;
            --rarity-orange: #FFA500;
            --rarity-purple: #800080;
            --rarity-blue: #0000FF;
            --rarity-green: #008000;
            --rarity-white: #FFFFFF;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #skillTree {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Base node styles */
        .node {
            position: absolute;
            width: 70px;
            height: 70px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 3px;
            font-size: 12px;
            word-wrap: break-word;
            overflow: visible;
            position: relative;
            background-clip: padding-box;
            z-index: 1;
        }

        /* Star shape with outline */
        .node.fundamental {
            width: 110px;
            height: 90px;
            background-clip: padding-box;
            position: relative;
        }

        .node.fundamental::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            clip-path: polygon(50% 0%,
                    61% 35%,
                    98% 35%,
                    68% 57%,
                    79% 91%,
                    50% 70%,
                    21% 91%,
                    32% 57%,
                    2% 35%,
                    39% 35%);
            z-index: -1;
        }


        /* Diamond shape */
        .node.major {
            width: 70px;
            height: 70px;
        }

        .node.major::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            z-index: -1;
        }

        /* Circle shape */
        .node.minor {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: visible;
            /* Allow outline to be visible */
        }

        /* Update inner container for circle */
        .node.minor::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            z-index: -1;
        }

        /* Add specific styling for minor node's inner container */
        .node.minor>div {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            /* Make inner content round too */
            overflow: hidden;
            /* Keep text inside circle */
            margin: 0;
            /* Remove any margin */
            padding: 0;
            /* Remove any padding */
        }

        /* Square shape */
        .node.keystone {
            width: 63px;
            height: 65px;
        }

        .node.keystone::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            z-index: -1;
        }

        /* Heart shape */
        .node.project {
            width: 100px;
            height: 100px;
            position: relative;
            overflow: visible;
        }

        .node.project::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 2px;
            right: -2px;
            bottom: -2px;
            /* Heart shape clip path */
            clip-path: path('M50,90 C25,70 0,50 0,20 C0,9 10,0 25,0 C35,0 45,10 50,20 C55,10 65,0 75,0 C90,0 100,9 100,20 C100,50 75,70 50,90');
            z-index: -1;
        }

        .node.project > div {
            width: calc(100% - 8px); /* Slightly smaller than the outline */
            height: calc(100% - 8px);
            margin: 4px; 
            padding-bottom: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Use slightly smaller heart for inner content */
            clip-path: path('M50,85 C28,67 5,48 5,20 C5,10 15,2 28,2 C37,2 45,10 50,20 C55,10 63,2 72,2 C85,2 95,10 95,20 C95,48 72,67 50,85');
            position: relative;
            white-space: pre-line; /* Allow line breaks */
        }

        .node-content-locked {
            font-size: 14px;
            content: '🔒';
            /* Lock emoji */
        }

        .node-content-unknown {
            font-size: 14px;
            content: '?';
        }

        /* Rarity colors */
        .node.rarity-gold::before {
            background-color: var(--rarity-gold);
        }

        .node.rarity-orange::before {
            background-color: var(--rarity-orange);
        }

        .node.rarity-purple::before {
            background-color: var(--rarity-purple);
        }

        .node.rarity-blue::before {
            background-color: var(--rarity-blue);
        }

        .node.rarity-green::before {
            background-color: var(--rarity-green);
        }

        .node.rarity-white::before {
            background-color: var(--rarity-white);
        }

        .edge {
            position: absolute;
            background: #4a90e2;
            height: 4px;
            /* Made thicker */
            pointer-events: none;
            transition: all 0.3s;
            transform-origin: left center;
            z-index: 2;
            /* Added to ensure edges appear under nodes */
        }

        .edge::after {
            content: '';
            position: absolute;
            right: -8px;
            top: -6px;
            /* Adjusted for thicker line */
            width: 0;
            height: 0;
            border-left: 12px solid #4a90e2;
            /* Made arrow bigger */
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
        }

        .edge.active {
            background: #00ff00;
        }

        .edge.active::after {
            border-left-color: #00ff00;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        #stats {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
        }

        /* Add these styles */
        #legend, #rarity-legend {
            margin-top: 20px;
            padding: 10px 15px; /* Reduced right padding */
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        .legend-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
        }

        .count {
            margin-left: auto;
            padding-left: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            justify-content: flex-start;
            white-space: nowrap;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Grid styles */
        .grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: -2;
        }

        .grid-line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        }

        /* Add these styles to your existing CSS */
        .gauge-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .gauge-label {
            width: 30px;
            font-size: 14px;
            color: white;
        }

        .gauge-track {
            flex: 1;
            height: 24px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .gauge-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .gauge-value {
            width: 64px;
            text-align: right;
            font-size: 14px;
        }

        /* Circular gauge styles */
        .total-gauges-container {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 25px 20px 35px 20px; 
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-height: 150px; 
        }

        .circular-gauge {
            position: relative;
            width: 120px;
            height: 120px;
            text-align: center;
        }

        .gauge-circle {
            transform: rotate(-180deg);
            fill: none;
            stroke-width: 8;
        }

        .gauge-circle-bg {
            stroke: #333;
        }

        .gauge-circle-fill {
            stroke-linecap: round;
            transition: stroke-dasharray 0.3s ease;
            transform-origin: center;
        }

        .gauge-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 100%;
            color: white;
        }

        .gauge-percent {
            font-size: 24px;
            font-weight: bold;
        }

        .gauge-count {
            font-size: 12px;
            margin-top: 5px;
        }

        .gauge-label {
            position: relative;
            margin-top: 8px;
            font-size: 14px;
            color: white;
        }

    </style>
</head>

<body>
    <div id="container">
        <div id="skillTree"></div>
        <div id="stats">
            <div>Active Nodes: <span id="activeNodes">0</span> / <span id="totalNodes">0</span> (<span id="activeNodesPercent">0%</span>)</div>
            <div>Active Edges: <span id="activeEdges">0</span> / <span id="totalEdges">0</span> (<span id="activeEdgesPercent">0%</span>)</div>

            <div class="total-gauges-container">
                <div class="circular-gauge" id="totalDomainGauge"></div>
                <div class="circular-gauge" id="totalRarityGauge"></div>
            </div>

            <div id="legend">
                <div class="legend-title">Domains:</div>
                <!-- Gauge bars will be inserted here -->
            </div>
            <div id="rarity-legend">
                <div class="legend-title">Rarities:</div>
                <!-- Gauge bars will be inserted here -->
            </div>
        </div>
        <div id="controls">
            <button id="zoomIn">+</button>
            <button id="zoomOut">-</button>
            <button id="fitScreen">Fit Screen</button>
        </div>
    </div>
    <script>
        class SkillTree {
            constructor(containerId, data) {
                this.container = document.getElementById(containerId);
                this.data = data;
                this.scale = 1;
                this.dragStart = {
                    x: 0,
                    y: 0
                };
                this.offset = {
                    x: 0,
                    y: 0
                };
                this.activeNodes = new Set();
                this.activeEdges = new Set();

                this.showGrid = true; // Add this
                this.data.domains = {
                    "learn": "#4A90E2",
                    "computer-science": "#F5A623",
                    "web-development": "#7ED321",
                    "math": "#BD10E0",
                    "machine-learning": "#FF5733"
                };

                this.init();
            }

            createGrid() {
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.classList.add('grid');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');

                // Create grid lines
                const gridSize = 50;
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;

                // Vertical lines
                for (let x = 0; x <= width; x += gridSize) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', height);
                    line.classList.add('grid-line');
                    svg.appendChild(line);
                }

                // Horizontal lines
                for (let y = 0; y <= height; y += gridSize) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', width);
                    line.setAttribute('y2', y);
                    line.classList.add('grid-line');
                    svg.appendChild(line);
                }

                this.container.appendChild(svg);
            }

            isEdgeActive(edge) {
                const sourceNode = this.findNodeData(edge.source);
                const targetNode = this.findNodeData(edge.target);
                return sourceNode.explored && targetNode.explored;
            }

            init() {
                this.setupContainer();
                this.createGrid();

                // Initialize active nodes first
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                allNodes.forEach(nodeData => {
                    if (nodeData.explored) {
                        this.activeNodes.add(nodeData.id);
                    }
                });

                this.createNodes();
                this.createEdges();
                this.setupEventListeners();
                this.updateStats();
            }

            setupContainer() {
                this.container.style.transform = `scale(${this.scale})
            translate(${this.offset.x}px, ${this.offset.y}px)`;
            }

            createNodes() {
                // Create nodes for each type
                Object.entries(this.data.nodes).forEach(([type, nodes]) => {
                    if (Array.isArray(nodes)) {
                        nodes.forEach(node => this.createNode(node));
                    } else {
                        this.createNode(nodes);
                    }
                });
            }

            createNode(nodeData) {
                const node = document.createElement('div');
                node.className = `node ${nodeData.type}`;

                // Add rarity class
                if (nodeData.rarity) {
                    node.classList.add(`rarity-${nodeData.rarity}`);
                } else {
                    node.classList.add('rarity-white'); // default rarity
                }

                node.id = nodeData.id;
                node.style.left = `${nodeData.position.x}px`;
                node.style.top = `${nodeData.position.y}px`;

                this.updateNodeDisplay(node, nodeData);
                this.container.appendChild(node);
            }

            isNodeAccessible(nodeId) {
                const nodeData = this.findNodeData(nodeId);

                // Check incoming connections
                const hasActiveIncomingConnection = Object.values(this.data.nodes)
                    .flat()
                    .filter(node => node)
                    .some(node =>
                        node.connections &&
                        node.connections.includes(nodeId) &&
                        this.activeNodes.has(node.id)
                    );

                // Check outgoing connections
                const hasActiveOutgoingConnection = nodeData.connections &&
                    nodeData.connections.some(targetId => this.activeNodes.has(targetId));

                return hasActiveIncomingConnection || hasActiveOutgoingConnection;
            }

            updateNodeDisplay(node, nodeData) {
                // Clear current content
                node.innerHTML = '';

                // Create inner container
                const innerContainer = document.createElement('div');
                innerContainer.style.width = '100%';
                innerContainer.style.height = '100%';
                innerContainer.style.display = 'flex';
                innerContainer.style.alignItems = 'center';
                innerContainer.style.justifyContent = 'center';
                innerContainer.style.clipPath = this.getClipPath(nodeData.type);

                if (this.activeNodes.has(nodeData.id)) {
                    // Active node
                    innerContainer.style.backgroundColor = this.data.domains[nodeData.domain];
                    this.createTextContainer(innerContainer, nodeData.title);
                } else {
                    // Inactive node
                    innerContainer.style.backgroundColor = '#333';
                    if (this.isNodeAccessible(nodeData.id)) {
                        innerContainer.textContent = '?';
                    } else {
                        innerContainer.textContent = '🔒';
                    }
                }

                node.appendChild(innerContainer);
            }

            getClipPath(type) {
                switch (type) {
                    case 'fundamental':
                        return 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
                    case 'major':
                        return 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                    case 'minor':
                        return 'circle(50%)';
                    case 'keystone':
                        return 'none';
                    case 'project':
                        return 'path("M45,85 C23,67 0,48 0,20 C0,10 10,2 23,2 C32,2 40,10 45,20 C50,10 58,2 67,2 C80,2 90,10 90,20 C90,48 67,67 45,85")';
                    default:
                        return 'none';
                }
            }

            createTextContainer(container, text) {
                if (!container || !text) return; // Add safety check

                const textWrapper = document.createElement('div');
                textWrapper.style.width = '80%';
                textWrapper.style.display = 'flex';
                textWrapper.style.flexDirection = 'column';
                textWrapper.style.alignItems = 'center';
                textWrapper.style.justifyContent = 'center';
                textWrapper.style.wordBreak = 'break-word';
                textWrapper.style.textAlign = 'center';
                textWrapper.style.whiteSpace = 'pre-line';


                // Safe check for parent element and its class
                const nodeType = container.parentElement ? container.parentElement.className.split(' ')[1] : '';

                // Specific adjustments based on node type
                switch(nodeType) {
                    case 'project':
                        // textWrapper.style.transform = 'translateY(-75%)';
                        break;
                    case 'fundamental':
                        textWrapper.style.width = '70%';
                        break;
                    case 'major':
                        textWrapper.style.width = '75%';
                        break;
                }

                // Rest of the method remains the same...
                if (text.length > 20) {
                    textWrapper.style.fontSize = '8px';
                } else if (text.length > 15) {
                    textWrapper.style.fontSize = '9px';
                } else if (text.length > 10) {
                    textWrapper.style.fontSize = '10px';
                } else {
                    textWrapper.style.fontSize = '11px';
                }

                // Line break logic
                const words = text.split(' ');
                let line = '';
                let lines = [];
                
                // Set threshold based on node type
                let threshold = 12; // default
                switch(nodeType) {
                    case 'fundamental':
                        threshold = 15;
                        break;
                    case 'minor':
                        threshold = 10;
                        break;
                }

                words.forEach(word => {
                    if (line.length + word.length > threshold) {
                        lines.push(line);
                        line = word;
                    } else {
                        line = line ? line + ' ' + word : word;
                    }
                });
                if (line) {
                    lines.push(line);
                }

                textWrapper.textContent = lines.join('\n');
                container.appendChild(textWrapper);
            }

            createEdges() {
                // Get all nodes in a flat array
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);

                // Create edges from connections
                allNodes.forEach(node => {
                    if (node.connections) {
                        node.connections.forEach(targetId => {
                            const edgeElement = document.createElement('div');
                            edgeElement.className = 'edge';
                            this.updateEdgePosition(edgeElement, node.id, targetId);
                            edgeElement.dataset.source = node.id;
                            edgeElement.dataset.target = targetId;
                            this.container.appendChild(edgeElement);

                            // If both nodes are explored, activate the edge
                            if (node.explored && this.findNodeData(targetId).explored) {
                                this.activeEdges.add(`${node.id}-${targetId}`);
                                edgeElement.classList.add('active');
                            }
                        });
                    }
                });
            }

            updateEdgePosition(edgeElement, sourceId, targetId) {
                const source = document.getElementById(sourceId);
                const target = document.getElementById(targetId);

                if (!source || !target) return;

                const sourceRect = source.getBoundingClientRect();
                const targetRect = target.getBoundingClientRect();

                // Get positions relative to container
                const containerRect = this.container.getBoundingClientRect();

                // Calculate center points
                const sourceX = sourceRect.left - containerRect.left + sourceRect.width / 2;
                const sourceY = sourceRect.top - containerRect.top + sourceRect.height / 2;
                const targetX = targetRect.left - containerRect.left + targetRect.width / 2;
                const targetY = targetRect.top - containerRect.top + targetRect.height / 2;

                // Calculate angle
                const dx = targetX - sourceX;
                const dy = targetY - sourceY;
                const angle = Math.atan2(dy, dx);

                // Get node radii (half of width for simplicity)
                const sourceRadius = sourceRect.width / 2;
                const targetRadius = targetRect.width / 2;

                // Calculate edge start and end points at node boundaries
                const startX = sourceX + sourceRadius * Math.cos(angle);
                const startY = sourceY + sourceRadius * Math.sin(angle);
                const endX = targetX - targetRadius * Math.cos(angle);
                const endY = targetY - targetRadius * Math.sin(angle);

                // Calculate new length and position
                const length = Math.sqrt(
                    Math.pow(endX - startX, 2) +
                    Math.pow(endY - startY, 2)
                );

                // Position the edge
                edgeElement.style.width = `${length}px`;
                edgeElement.style.left = `${startX}px`;
                edgeElement.style.top = `${startY}px`;
                edgeElement.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
            }

            setupEventListeners() {
                // Node click handling
                this.container.addEventListener('click', (e) => {
                    const node = e.target.closest('.node');
                    if (node) {
                        this.toggleNode(node);
                    }
                });

                // Dragging
                let isDragging = false;
                let startX, startY;

                // Add mousedown listener to the whole window
                window.addEventListener('mousedown', (e) => {
                    // Only start drag if not clicking a node
                    if (!e.target.closest('.node')) {
                        isDragging = true;
                        startX = e.clientX - this.offset.x;
                        startY = e.clientY - this.offset.y;
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    this.offset.x = e.clientX - startX;
                    this.offset.y = e.clientY - startY;
                    this.updateTransform();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Zooming
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.scale *= 1.2;
                    this.updateTransform();
                });

                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.scale /= 1.2;
                    this.updateTransform();
                });

                document.getElementById('fitScreen').addEventListener('click', () => {
                    this.fitToScreen();
                });

                // Mouse wheel zooming
                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= delta;
                    this.updateTransform();
                });
            }

            toggleNode(node) {
                const nodeId = node.id;
                if (this.activeNodes.has(nodeId)) {
                    this.deactivateNode(node);
                } else {
                    this.activateNode(node);
                }
                this.updateStats();
            }

            activateNode(node) {
                const nodeId = node.id;
                const nodeData = this.findNodeData(nodeId);

                this.activeNodes.add(nodeId);
                this.updateNodeDisplay(node, nodeData);

                // Update edges
                nodeData.connections?.forEach(targetId => {
                    if (this.activeNodes.has(targetId)) {
                        this.activeEdges.add(`${nodeId}-${targetId}`);
                        const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                            .find(el =>
                                (el.dataset.source === nodeId && el.dataset.target === targetId) ||
                                (el.dataset.source === targetId && el.dataset.target === nodeId)
                            );
                        if (edgeElement) edgeElement.classList.add('active');
                    }
                });

                // Update edges where this node is the target
                Object.values(this.data.nodes)
                    .flat()
                    .filter(n => n && n.connections?.includes(nodeId))
                    .forEach(sourceNode => {
                        if (this.activeNodes.has(sourceNode.id)) {
                            this.activeEdges.add(`${sourceNode.id}-${nodeId}`);
                            const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                                .find(el =>
                                    (el.dataset.source === sourceNode.id && el.dataset.target === nodeId) ||
                                    (el.dataset.source === nodeId && el.dataset.target === sourceNode.id)
                                );
                            if (edgeElement) edgeElement.classList.add('active');
                        }
                    });

                this.updateConnectedNodesDisplay(nodeId);
            }

            deactivateNode(node) {
                const nodeId = node.id;
                const nodeData = this.findNodeData(nodeId);

                this.activeNodes.delete(nodeId);
                this.updateNodeDisplay(node, nodeData);

                // Update edges
                nodeData.connections?.forEach(targetId => {
                    this.activeEdges.delete(`${nodeId}-${targetId}`);
                    const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                        .find(el =>
                            (el.dataset.source === nodeId && el.dataset.target === targetId) ||
                            (el.dataset.source === targetId && el.dataset.target === nodeId)
                        );
                    if (edgeElement) edgeElement.classList.remove('active');
                });

                // Update edges where this node is the target
                Object.values(this.data.nodes)
                    .flat()
                    .filter(n => n && n.connections?.includes(nodeId))
                    .forEach(sourceNode => {
                        this.activeEdges.delete(`${sourceNode.id}-${nodeId}`);
                        const edgeElement = Array.from(this.container.getElementsByClassName('edge'))
                            .find(el =>
                                (el.dataset.source === sourceNode.id && el.dataset.target === nodeId) ||
                                (el.dataset.source === nodeId && el.dataset.target === sourceNode.id)
                            );
                        if (edgeElement) edgeElement.classList.remove('active');
                    });

                this.updateConnectedNodesDisplay(nodeId);
            }

            updateConnectedNodesDisplay(nodeId) {
                const nodeData = this.findNodeData(nodeId);

                // Update nodes that this node connects to
                if (nodeData.connections) {
                    nodeData.connections.forEach(targetId => {
                        const targetNode = document.getElementById(targetId);
                        if (targetNode) {
                            this.updateNodeDisplay(targetNode, this.findNodeData(targetId));
                        }
                    });
                }

                // Update nodes that connect to this node
                Object.values(this.data.nodes)
                    .flat()
                    .filter(node => node && node.connections && node.connections.includes(nodeId))
                    .forEach(sourceNode => {
                        const sourceElement = document.getElementById(sourceNode.id);
                        if (sourceElement) {
                            this.updateNodeDisplay(sourceElement, sourceNode);
                        }
                    });
            }

            updateEdgeStyle(edge) {
                const edgeId = `${edge.source}-${edge.target}`;
                const edgeElement = this.findEdgeElement(edge);
                if (edgeElement) {
                    if (this.activeEdges.has(edgeId)) {
                        edgeElement.classList.add('active');
                    } else {
                        edgeElement.classList.remove('active');
                    }
                }
            }

            findNodeData(nodeId) {
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                return allNodes.find(node => node.id === nodeId);
            }

            findEdgeElement(edge) {
                return Array.from(this.container.getElementsByClassName('edge'))
                    .find(el =>
                        el.dataset.source === edge.source &&
                        el.dataset.target === edge.target
                    );
            }

            updateTransform() {
                if (this.container) {
                    this.container.style.transform =
                        `translate(${this.offset.x}px, ${this.offset.y}px) scale(${this.scale})`;
                }
            }

            fitToScreen() {
                // Get root node and all nodes
                const rootNode = document.getElementById('root');
                const nodes = Array.from(this.container.getElementsByClassName('node'));
                if (!rootNode || nodes.length === 0) return;

                // First, center on root node
                const containerRect = this.container.parentElement.getBoundingClientRect();
                const containerCenterX = containerRect.width / 2;
                const containerCenterY = containerRect.height / 2;

                // Reset scale initially
                this.scale = 1;
                this.updateTransform();

                // Get root node position
                const rootRect = rootNode.getBoundingClientRect();
                const rootCenterX = rootRect.left + (rootRect.width / 2);
                const rootCenterY = rootRect.top + (rootRect.height / 2);

                // Center on root
                this.offset.x = containerCenterX - rootCenterX;
                this.offset.y = containerCenterY - rootCenterY;
                this.updateTransform();

                // Now find the bounds of all nodes
                let minX = Infinity,
                    maxX = -Infinity;
                let minY = Infinity,
                    maxY = -Infinity;

                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    minX = Math.min(minX, rect.left);
                    maxX = Math.max(maxX, rect.right);
                    minY = Math.min(minY, rect.top);
                    maxY = Math.max(maxY, rect.bottom);
                });

                // Calculate required scale with padding
                const padding = 50;
                const width = maxX - minX + (padding * 2);
                const height = maxY - minY + (padding * 2);

                const scaleX = containerRect.width / width;
                const scaleY = containerRect.height / height;
                this.scale = Math.min(scaleX, scaleY);

                // Update one final time with new scale
                this.updateTransform();
            }

            createGaugeBar(container, label, percentage, color, count, total) {
                const gaugeBar = document.createElement('div');
                gaugeBar.className = 'gauge-bar';
                
                const labelEl = document.createElement('span');
                labelEl.className = 'gauge-label';
                labelEl.textContent = label;
                labelEl.style.color = color; 
                
                const track = document.createElement('div');
                track.className = 'gauge-track';
                
                const fill = document.createElement('div');
                fill.className = 'gauge-fill';
                fill.style.width = `${percentage}%`;
                fill.style.backgroundColor = color;
                
                const value = document.createElement('span');
                value.className = 'gauge-value';
                value.style.color = color;
                value.textContent = `${percentage.toFixed(1)}%`;
                
                track.appendChild(fill);
                gaugeBar.appendChild(labelEl);
                gaugeBar.appendChild(track);
                gaugeBar.appendChild(value);
                
                container.appendChild(gaugeBar);
            }

            createCircularGauge(container, percentage, color, count, total, label) {
                container.innerHTML = '';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 100 100');
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.transform = 'rotate(-90deg)'; // Rotate the SVG
                
                // Background circle
                const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                bgCircle.setAttribute('cx', '50');
                bgCircle.setAttribute('cy', '50');
                bgCircle.setAttribute('r', '45');
                // bgCircle.className = 'gauge-circle gauge-circle-bg';
                // Fix: Use setAttribute for SVG classes
                bgCircle.setAttribute('class', 'gauge-circle gauge-circle-bg');

                    
                // Progress circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '50');
                circle.setAttribute('cy', '50');
                circle.setAttribute('r', '45');
                // circle.className = 'gauge-circle gauge-circle-fill';
                // Fix: Use setAttribute for SVG classes
                bgCircle.setAttribute('class', 'gauge-circle gauge-circle-fill');
                circle.style.stroke = color;
                
                const circumference = 2 * Math.PI * 45;
                const fillLength = (percentage / 100) * circumference;

                // Add strokeDashoffset to start from top
                circle.style.strokeDasharray = `${circumference}`;
                circle.style.strokeDashoffset = circumference - fillLength;
                
                svg.appendChild(bgCircle);
                svg.appendChild(circle);
                
                // Add text elements
                const textContainer = document.createElement('div');
                textContainer.className = 'gauge-text';
                
                const percentText = document.createElement('div');
                percentText.className = 'gauge-percent';
                percentText.textContent = `${percentage.toFixed(1)}%`;
                
                const countText = document.createElement('div');
                countText.className = 'gauge-count';
                countText.textContent = `${count} / ${total}`;
                
                textContainer.appendChild(percentText);
                textContainer.appendChild(countText);
                
                const labelText = document.createElement('div');
                labelText.className = 'gauge-label';
                labelText.textContent = label;
                labelText.style.color = color;
                
                container.appendChild(svg);
                container.appendChild(textContainer);
                container.appendChild(labelText);
            }

            updateStats() {
                // Get total counts first
                const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
                const totalNodes = allNodes.length;
                const totalEdges = allNodes.reduce((count, node) =>
                    count + (node.connections?.length || 0), 0);

                // Count totals by domain and rarity
                const domainTotals = {};
                const rarityTotals = {
                    gold: 0,
                    orange: 0,
                    purple: 0,
                    blue: 0,
                    green: 0,
                    white: 0
                };

                allNodes.forEach(node => {
                    if (node.domain) {
                        domainTotals[node.domain] = (domainTotals[node.domain] || 0) + 1;
                    }
                    const rarity = node.rarity || 'white';
                    rarityTotals[rarity] = (rarityTotals[rarity] || 0) + 1;
                });

                // Update total counts
                document.getElementById('totalNodes').textContent = totalNodes;
                document.getElementById('totalEdges').textContent = totalEdges;
                document.getElementById('activeNodes').textContent = this.activeNodes.size;
                document.getElementById('activeEdges').textContent = this.activeEdges.size;

                // Update percentages
                const activeNodesPercent = ((this.activeNodes.size / totalNodes) * 100).toFixed(1);
                const activeEdgesPercent = ((this.activeEdges.size / totalEdges) * 100).toFixed(1);
                document.getElementById('activeNodesPercent').textContent = `${activeNodesPercent}%`;
                document.getElementById('activeEdgesPercent').textContent = `${activeEdgesPercent}%`;

                // Count active nodes by domain and rarity
                const domainCounts = {};
                const rarityCounts = {
                    gold: 0,
                    orange: 0,
                    purple: 0,
                    blue: 0,
                    green: 0,
                    white: 0
                };

                this.activeNodes.forEach(nodeId => {
                    const nodeData = this.findNodeData(nodeId);
                    if (nodeData) {
                        if (nodeData.domain) {
                            domainCounts[nodeData.domain] = (domainCounts[nodeData.domain] || 0) + 1;
                        }
                        const rarity = nodeData.rarity || 'white';
                        rarityCounts[rarity]++;
                    }
                });

                // Calculate totals for domains and rarities
                const totalDomainCount = Object.values(domainCounts).reduce((a, b) => a + b, 0);
                const totalDomainTotal = Object.values(domainTotals).reduce((a, b) => a + b, 0);
                const totalDomainPercentage = (totalDomainCount / totalDomainTotal) * 100;

                const totalRarityCount = Object.values(rarityCounts).reduce((a, b) => a + b, 0);
                const totalRarityTotal = Object.values(rarityTotals).reduce((a, b) => a + b, 0);
                const totalRarityPercentage = (totalRarityCount / totalRarityTotal) * 100;

                // Update circular gauges for totals
                this.createCircularGauge(
                    document.getElementById('totalDomainGauge'),
                    totalDomainPercentage,
                    '#4A90E2', // Use appropriate color
                    totalDomainCount,
                    totalDomainTotal,
                    'Total Domains'
                );

                this.createCircularGauge(
                    document.getElementById('totalRarityGauge'),
                    totalRarityPercentage,
                    '#FFD700', // Use appropriate color
                    totalRarityCount,
                    totalRarityTotal,
                    'Total Rarities'
                );

                // Update domain gauge bars
                const legend = document.getElementById('legend');
                legend.innerHTML = '<div class="legend-title">Domains:</div>';
                Object.entries(this.data.domains).forEach(([domain, color]) => {
                    const active = domainCounts[domain] || 0;
                    const total = domainTotals[domain];
                    const percentage = total > 0 ? (active / total) * 100 : 0;
                    this.createGaugeBar(
                        legend,
                        domain === 'learn' ? '학습' :
                        domain === 'computer-science' ? 'CS' :
                        domain === 'web-development' ? 'Web' :
                        domain === 'math' ? 'Math' :
                        domain === 'machine-learning' ? 'ML' : domain,
                        percentage,
                        color,
                        active,
                        total
                    );
                });

                // Update rarity gauge bars
                const rarityLegend = document.getElementById('rarity-legend');
                rarityLegend.innerHTML = '<div class="legend-title">Rarities:</div>';
                const rarityLabels = {
                    'gold': '초월',
                    'orange': '전설',
                    'purple': '영웅',
                    'blue': '희귀',
                    'green': '일반',
                    'white': '기본'
                };
                Object.entries(rarityTotals).forEach(([rarity, total]) => {
                    const active = rarityCounts[rarity] || 0;
                    const percentage = total > 0 ? (active / total) * 100 : 0;
                    const color = getComputedStyle(document.documentElement)
                        .getPropertyValue(`--rarity-${rarity}`).trim();
                    this.createGaugeBar(rarityLegend, rarityLabels[rarity], percentage, color, active, total);
                });

                // Update circular gauges style
                const style = document.createElement('style');
                style.textContent = `
                    .gauge-circle-bg {
                        stroke: #333;
                        stroke-width: 8;
                    }
                    .gauge-circle-fill {
                        stroke-width: 8;
                        stroke-linecap: round;
                        transform: rotate(-90deg);
                        transform-origin: center;
                        transition: stroke-dasharray 0.3s ease;
                    }
                `;
                document.head.appendChild(style);

                // Update the circular gauges for totals
                if (totalDomainTotal > 0) {
                    this.createCircularGauge(
                        document.getElementById('totalDomainGauge'),
                        totalDomainPercentage,
                        '#4A90E2',
                        totalDomainCount,
                        totalDomainTotal,
                        'Total Domains'
                    );
                }

                if (totalRarityTotal > 0) {
                    this.createCircularGauge(
                        document.getElementById('totalRarityGauge'),
                        totalRarityPercentage,
                        '#FFD700',
                        totalRarityCount,
                        totalRarityTotal,
                        'Total Rarities'
                    );
                }
            }

            // Add method to toggle grid
            toggleGrid() {
                this.showGrid = !this.showGrid;
                const grid = this.container.querySelector('.grid');
                if (grid) {
                    grid.style.display = this.showGrid ? 'block' : 'none';
                }
            }

        }


        fetch('skill-tree.json')
            .then(response => response.json())
            .then(data => {
                const skillTree = new SkillTree('skillTree', data);
            });
    </script>
</body>

</html>